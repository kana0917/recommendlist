# -*- coding: utf-8 -*-
"""Untitled4.ipynb의 사본

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1OhX404IG29nQ1bS3WBS6HULM_F2t4q1U
"""

from sklearn.decomposition import TruncatedSVD
from scipy.sparse.linalg import svds

import pandas as pd
import numpy as np

from google.colab import files
myfile = files.upload()

from google.colab import files
myfile = files.upload()

#스터디전체목록 가져오기
df_class= pd.read_csv('/content/class.csv', encoding='CP949')
#df_class= pd.read_csv('/content/class.csv')
class_count=df_class.shape[0] 
df_class.head()
#df_class.iloc[0]['goal']

#이용자들의 평점 가져오기(+하트는 1점)
df_rating = pd.read_csv('/content/ratings.csv')
df_rating.head()

grouping=df_rating.groupby(by=['userId'], as_index=False).count()
grouping=grouping[['userId','classId']]
rating_count=grouping.rename(columns={'classId':'count'})
a=rating_count.iloc[0]['count']

#전체 스터디목록에 대한 이용자평점을 테이블로 나타내기
user_class_rating = df_rating.pivot( index='userId',columns='classId',values='rating').fillna(0)
user_class_rating.head()

#데이터 정규화
matrix = user_class_rating.values
user_rating_mean = np.mean(matrix, axis = 1)
#
user_rating_std = np.std(matrix, axis = 1)
matrix_normalization = matrix - user_rating_mean.reshape(-1, 1)
#
matrix_normalization = matrix_normalization / user_rating_std.reshape(-1, 1)

pd.DataFrame(matrix_normalization, columns = user_class_rating.columns).head()

#행렬분해
U, s, Vt = svds(matrix_normalization, k = 10)
s = np.diag(s)

#특이값으로 행렬부분복원
predict_rating = np.dot(np.dot(U, s), Vt) 
#
predict_rating = predict_rating *  user_rating_std.reshape(-1, 1)
predict_rating = predict_rating +  user_rating_mean.reshape(-1, 1)

pred = pd.DataFrame(predict_rating, columns = user_class_rating.columns)
#추천스터디 사용할 userid, 추천개수 받기
uid=1
recommendN=10
pred
user_goal="Act"

#스터디추천 함수
def recommend_class(df_svd_preds,  class_df, ratings_df, user_id, num_recommendations):
    user_row_number = user_id - 1 
    #평점 높은순 정렬
    sorted_user_predictions = df_svd_preds.iloc[user_row_number].sort_values(ascending=False)
    
    #사용자가 매긴 평점 가져오기
    user_data = ratings_df[ratings_df.userId == user_id]
    user_history = pd.merge(user_data, class_df, on = 'classId').sort_values(['rating'], ascending=False)

    #사용자가 이용한 스터디 제외
    recommendations = class_df[~class_df['classId'].isin(user_history['classId'])]
    
    recommendations = pd.merge(recommendations, pd.DataFrame(sorted_user_predictions).reset_index(), on = 'classId')
   
    recommendations = recommendations.rename(columns = {user_row_number: 'Predictions'}).sort_values('Predictions', ascending = False).iloc[:num_recommendations, :]

    return  recommendations

#pd.set_option('mode.chained_assignment',  None) 
#새로운 사용자일 경우 평점이 높은 스터디 추천 + 사용자의 목표,선호하는 keyword에 해당하는 스터디가 있으면 해당 스터디를 우선추천
user_keyword="A"
newuser_recommendlist=pd.DataFrame(index=range(0,5), columns=['classId', 'title','goal'])
if rating_count.iloc[uid-1]['count'] <= 1: #새로운 사용자임을 확인

  for i in range(0,class_count+1):
    j=0
    if user_goal in df_class.iloc[i]['goal'] or keyword in df_class.iloc[i]['goal']:
      newuser_recommendlist.loc[j]=df_class.iloc[i]
      j=j+1
    #목표가 맞는거 우선추천하고 5개가 안되면 평점이 높은 스터디를 더해주어 5개 추천하기
    list_count=newuser_recommendlist.shape[0]
    if list_count<5:
      df_sorted_by_values=pd.DataFrame(index=range(0,5), columns=['classId', 'title','goal'])
      df_sorted_by_values = df_class.sort_values(['rating'] ,ascending=False)#평점순으로 배열한 클래스 5개 newuser_recommendlist에 추가하기
    #newuser_recommendlist 5개로 자르기
    result=pd.concat([newuser_recommendlist,df_sorted_by_values],ignore_index=True)
    newuser_result=result.iloc[[0,1,2,3,4]]
#기존 사용자들의 스터디 추천
else:
  recommend_list = recommend_class(pred, df_class , df_rating, uid, recommendN)
 
  reflect_goal=recommend_list.reset_index(drop=True)[["classId","title","Predictions","goal"]]

  #사용자정보의 목표를 이용하여 추천리스트에서 사용자의 목표와 맞는 클래스를 우선추천하기
  print(reflect_goal[["Predictions","goal"]])

  for i in range(0,10):
    if user_goal in reflect_goal.iloc[i]['goal']:
      if reflect_goal.iloc[i]['Predictions'] >= user_rating_mean[uid-1]:
        print(reflect_goal.iloc[i]['Predictions'])
        reflect_goal.iloc[i]['Predictions']= 5.0
        print(reflect_goal.iloc[i]['Predictions'])

  reflect_goal.sort_values('Predictions',ascending=False)
  reflect_goal=reflect_goal.reset_index(drop=True)[["classId","title"]]
  reflect_goal.head()

#사용자의 추천스터디 목록보기
#pd.set_option('mode.chained_assignment',  None) 
recommend_list = recommend_class(pred, df_class , df_rating, uid, recommendN)
reflect_goal=recommend_list.reset_index(drop=True)[["classId","title","Predictions","goal"]]

#사용자정보의 목표를 이용하여 추천리스트에서 사용자의 목표와 맞는 클래스를 우선추천하기
print(reflect_goal[["Predictions","goal"]])

user_goal="Act"

#사용자의 목표가 스터디의 목표에 해당하는 게 있으면 우선순위 올려놓기
for i in range(0,10):
  if user_goal in reflect_goal.iloc[i]['goal']:
    if reflect_goal.iloc[i]['Predictions'] >= user_rating_mean[uid-1]:
      print(reflect_goal.iloc[i]['Predictions'])
      reflect_goal.iloc[i]['Predictions']= 5.0
      print(reflect_goal.iloc[i]['Predictions'])


reflect_goal.sort_values('Predictions',ascending=False)
reflect_goal=reflect_goal.reset_index(drop=True)[["classId","title"]]
reflect_goal.head()
